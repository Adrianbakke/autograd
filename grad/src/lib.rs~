use std::ops;
use std::cell::RefCell;
use std::rc::Rc;

use matrix;

#[derive(Debug, Clone)]
pub struct Var{
    pub value:      u32,
    pub children:   RefCell<Vec<Child>>,
    pub grad_value: RefCell<Option<u32>>,
}

#[derive(Debug, Clone)]
pub struct Child {
    pub weight: u32,
    pub grad:   Rc<Var>, 
}

#[derive(Debug, Clone)]
pub struct Graph<'a> {
    elements: Vec<&'a Var>,
}

impl<'a> Graph<'a> {
    pub fn create() -> Self {
        Self { elements: Vec::new() }
    }

    pub fn add(&mut self, var: &'a Var) {
        self.elements.push(var);
    }
}

impl Var {
    pub fn new(value: u32) -> Self {
        Self {
            value,
            children: RefCell::new(Vec::new()),
            grad_value: RefCell::new(None),
        }
    }

    /*
    pub fn grad(&self) -> RefCell<Option<u32>> {
        println!("{:?}", self.grad_value);
        match *self.grad_value {
            None => {
                println!("in");
                let mut grad = 0;
                for child in self.children.borrow().iter() {
                    let w = child.weight;
                    let g = (*child.grad.grad()).unwrap();
                    println!("{},{}",g,w);
                    grad += w*g;
                }
                RefCell::new(Some(grad))
            }
            _    => self.grad_value
        }
    }
    */

    pub fn setGrad(&self, set2: Option<u32>) {
           *self.grad_value.borrow_mut() = set2;
    }
}

impl Child {
    pub fn new(weight: u32, grad: Rc<Var>) -> Self {
        Self { weight, grad }
    }
}

impl<'a> ops::Add<&Var> for Var {
    type Output = &'a Self;

    /*
    fn add(self, rhs: Self) -> Var {
        let z = Rc::new(Var::new(self.0.value + rhs.0.value));
        self.0.children.borrow_mut().push(Child::new(1, Rc::clone(&z))); 
        rhs.0.children.borrow_mut().push(Child::new(1,Rc::clone(&z))); 
        A(z) 
    }
    */

    fn add(self, rhs: Self) -> Var {
        Var::new(self.value + rhs.value)
    }
}

/*
impl ops::Mul for Var {
    type Output = Self;

    fn mul(mut self, mut rhs: Self) -> Self {
        let z = Self::new(self.value*rhs.value);
        self.children.push(Child::new(rhs.value, z.clone()));
        rhs.children.push(Child::new(self.value, z.clone()));
        z
    }
}
*/

pub fn it_works(){
    let mut g: Graph = Graph::create();
    let x = Var::new(10);
    let y = Var::new(7);
    g.add(&x);
    g.add(&y);
    let z = x+y;

    println!("{:?}", g);
    //println!("{:?}", z);
}

